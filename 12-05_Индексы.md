# Домашнее задание к занятию «Индексы» - `Юрий Чеканов`

### Задание 1

Напишите запрос к учебной базе данных, который вернёт процентное отношение общего размера всех индексов к общему размеру всех таблиц.

```mysql
select table_schema, 
concat(round(sum(index_length)/(select sum(data_length) from INFORMATION_SCHEMA.tables where TABLE_SCHEMA='sakila')*100,2), '%') as 'Index share in DB volume'
from information_schema.tables
where TABLE_SCHEMA='sakila';
```

| TABLE_SCHEMA | Index share in DB volume |
| ------------ | ------------------------ |
| sakila       | 54.68%                   |

### Задание 2

Выполните explain analyze следующего запроса:

```mysql
select distinct concat(c.last_name, ' ', c.first_name), 
sum(p.amount) over (partition by c.customer_id, f.title)
from payment p, rental r, customer c, inventory i, film f
where date(p.payment_date) = '2005-07-30' and p.payment_date = r.rental_date and r.customer_id = c.customer_id and i.inventory_id = r.inventory_id
```
<details>
<summary>explain analyze</summary>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8"/>
</head>
<body>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8"/>
</head>
<body>
<table><tr><th colspan="1">explain analyze<br>select distinct concat(c.last_name, ' ', c.first_name), <br>sum(p.amount) over (partition by c.customer_id, f.title)<br>from payment p, rental r, customer c, inventory i, film f<br>where date(p.payment_date) = '2005-07-30' and p.payment_date = r.rental_date and r.customer_id = c.customer_id and i.inventory_id = r.inventory_id</th></tr><tr><th>EXPLAIN</th></tr><tr class="odd"><td>-&gt; Table scan on &lt;temporary&gt;  (cost=2.50..2.50 rows=0) (actual time=15390.287..15390.404 rows=391 loops=1)<br>    -&gt; Temporary table with deduplication  (cost=0.00..0.00 rows=0) (actual time=15390.284..15390.284 rows=391 loops=1)<br>        -&gt; Window aggregate with buffering: sum(payment.amount) OVER (PARTITION BY c.customer_id,f.title )   (actual time=6164.707..14839.340 rows=642000 loops=1)<br>            -&gt; Sort: c.customer_id, f.title  (actual time=6164.636..6385.504 rows=642000 loops=1)<br>                -&gt; Stream results  (cost=10344602.65 rows=16005975) (actual time=0.373..4499.661 rows=642000 loops=1)<br>                    -&gt; Nested loop inner join  (cost=10344602.65 rows=16005975) (actual time=0.367..3796.205 rows=642000 loops=1)<br>                        -&gt; Nested loop inner join  (cost=8740003.64 rows=16005975) (actual time=0.363..3368.897 rows=642000 loops=1)<br>                            -&gt; Nested loop inner join  (cost=7135404.64 rows=16005975) (actual time=0.358..2870.670 rows=642000 loops=1)<br>                                -&gt; Inner hash join (no condition)  (cost=1581474.80 rows=15813000) (actual time=0.345..143.173 rows=634000 loops=1)<br>                                    -&gt; Filter: (cast(p.payment_date as date) = '2005-07-30')  (cost=1.65 rows=15813) (actual time=0.027..21.028 rows=634 loops=1)<br>                                        -&gt; Table scan on p  (cost=1.65 rows=15813) (actual time=0.018..12.672 rows=16044 loops=1)<br>                                    -&gt; Hash<br>                                        -&gt; Covering index scan on f using idx_title  (cost=103.00 rows=1000) (actual time=0.039..0.208 rows=1000 loops=1)<br>                                -&gt; Covering index lookup on r using rental_date (rental_date=p.payment_date)  (cost=0.25 rows=1) (actual time=0.003..0.004 rows=1 loops=634000)<br>                            -&gt; Single-row index lookup on c using PRIMARY (customer_id=r.customer_id)  (cost=0.00 rows=1) (actual time=0.000..0.000 rows=1 loops=642000)<br>                        -&gt; Single-row covering index lookup on i using PRIMARY (inventory_id=r.inventory_id)  (cost=0.00 rows=1) (actual time=0.000..0.000 rows=1 loops=642000)<br></td></tr>
</table></body></html>
 </details>


- перечислите узкие места;
  Убрать лишние таблицы **film**, **rental** и **inventory** из запроса.

- оптимизируйте запрос: внесите корректировки по использованию операторов, при необходимости добавьте индексы.

Исправить код запроса на:

```mysql
select distinct concat(c.last_name, ' ', c.first_name), 
sum(p.amount) over (partition by c.customer_id)
from payment p 
left join customer c on c.customer_id = p.customer_id
where date(p.payment_date) = '2005-07-30';
```

<details>
<summary>explain analyze</summary>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8"/>
</head>
<body>
<table><tr><th colspan="1">explain analyze<br>select distinct concat(c.last_name, ' ', c.first_name), <br>sum(p.amount) over (partition by c.customer_id)<br>from payment p <br>left join customer c on c.customer_id = p.customer_id<br>where date(p.payment_date) = '2005-07-30'</th></tr><tr><th>EXPLAIN</th></tr><tr class="odd"><td>-&gt; Table scan on &lt;temporary&gt;  (cost=2.50..2.50 rows=0) (actual time=10.304..10.366 rows=391 loops=1)<br>    -&gt; Temporary table with deduplication  (cost=0.00..0.00 rows=0) (actual time=10.302..10.302 rows=391 loops=1)<br>        -&gt; Window aggregate with buffering: sum(payment.amount) OVER (PARTITION BY c.customer_id )   (actual time=8.915..10.092 rows=634 loops=1)<br>            -&gt; Sort: c.customer_id  (actual time=8.886..8.943 rows=634 loops=1)<br>                -&gt; Stream results  (cost=7140.10 rows=15813) (actual time=0.090..8.714 rows=634 loops=1)<br>                    -&gt; Nested loop left join  (cost=7140.10 rows=15813) (actual time=0.083..7.860 rows=634 loops=1)<br>                        -&gt; Filter: (cast(p.payment_date as date) = '2005-07-30')  (cost=1605.55 rows=15813) (actual time=0.067..7.090 rows=634 loops=1)<br>                            -&gt; Table scan on p  (cost=1605.55 rows=15813) (actual time=0.054..5.698 rows=16044 loops=1)<br>                        -&gt; Single-row index lookup on c using PRIMARY (customer_id=p.customer_id)  (cost=0.25 rows=1) (actual time=0.001..0.001 rows=1 loops=634)<br></td></tr>
</table></body></html>
 </details>


Добавим индекс

```mysql
create index customer_amount on payment(payment_date, customer_id, amount)
```

<details>
<summary>explain analyze</summary>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8"/>
</head>
<body>
<table><tr><th colspan="1">explain analyze<br>select distinct concat(c.last_name, ' ', c.first_name), <br>sum(p.amount) over (partition by c.customer_id)<br>from payment p <br>left join customer c on c.customer_id = p.customer_id<br>where date(p.payment_date) = '2005-07-30'</th></tr><tr><th>EXPLAIN</th></tr><tr class="odd"><td>-&gt; Table scan on &lt;temporary&gt;  (cost=2.50..2.50 rows=0) (actual time=6.019..6.054 rows=391 loops=1)<br>    -&gt; Temporary table with deduplication  (cost=0.00..0.00 rows=0) (actual time=6.018..6.018 rows=391 loops=1)<br>        -&gt; Window aggregate with buffering: sum(payment.amount) OVER (PARTITION BY c.customer_id )   (actual time=5.193..5.877 rows=634 loops=1)<br>            -&gt; Sort: c.customer_id  (actual time=5.168..5.198 rows=634 loops=1)<br>                -&gt; Stream results  (cost=7140.10 rows=15813) (actual time=2.130..5.012 rows=634 loops=1)<br>                    -&gt; Nested loop left join  (cost=7140.10 rows=15813) (actual time=2.124..4.847 rows=634 loops=1)<br>                        -&gt; Filter: (cast(p.payment_date as date) = '2005-07-30')  (cost=1605.55 rows=15813) (actual time=2.107..4.254 rows=634 loops=1)<br>                            -&gt; Covering index scan on p using customer_amount  (cost=1605.55 rows=15813) (actual time=0.033..3.180 rows=16044 loops=1)<br>                        -&gt; Single-row index lookup on c using PRIMARY (customer_id=p.customer_id)  (cost=0.25 rows=1) (actual time=0.001..0.001 rows=1 loops=634)<br></td></tr>
</table></body></html>
</details>



### Задание 3*

Самостоятельно изучите, какие типы индексов используются в PostgreSQL. Перечислите те индексы, которые используются в PostgreSQL, а в MySQL — нет.

*Приведите ответ в свободной форме.*



 



